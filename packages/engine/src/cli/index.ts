// packages/engine/src/cli/index.ts
import { Command } from "commander";
import path from "path";
import fs from "fs-extra";
import { Logger } from "../core/logger.js";
import { ProjectDetector } from "../core/project-detector.js";
import { PlanGenerator } from "../core/plan-generator.js";
import { PlanExecutor } from "../core/plan-executor.js";
import { resolveRealProjectRoot } from "../utils/root.js";

const program = new Command();
program
  .name("mofix")
  .description("MoFix CLI – diagnose, plan, and apply project fixes")
  .version("0.1.0");

function makeLogger(verbose = false) {
  const log = (pfx: string) => (msg: string) => {
    if (verbose) console.log(`${pfx} ${msg}`);
  };
  return {
    info: log("ℹ️"),
    step: log("▶️"),
    success: log("✅"),
    warning: (msg: string) => console.warn(`⚠️ ${msg}`),
    error: (msg: string) => console.error(`❌ ${msg}`),
  };
}

// mofix plan
program
  .command("plan")
  .description("Generate a migration plan and print JSON to stdout")
  .argument("[projectPath]", "Path to project root (default: .)", ".")
  .option("--target <name>", "Deployment target (vercel|netlify|vscode)")
  .option("--verbose", "Verbose logs", false)
  .action(async (projectPath, opts) => {
    const logger = makeLogger(!!opts.verbose);
    try {
      const root = await resolveRealProjectRoot(path.resolve(projectPath));
      if (!(await fs.pathExists(root))) {
        logger.error(`Path not found: ${root}`);
        process.exitCode = 2;
        return;
      }

      const detector = new ProjectDetector(new Logger());
      const detection = await detector.detect(root);

      const generator = new PlanGenerator(new Logger());
      const plan = await generator.generate(detection, {
        projectPath: root,
        deploymentTarget: opts.target,
      });

      // stdout에 JSON 출력
      process.stdout.write(JSON.stringify({ ok: true, projectPath: root, detection, plan }, null, 2) + "\n");
    } catch (err: any) {
      process.stdout.write(JSON.stringify({ ok: false, error: err?.message || String(err) }, null, 2) + "\n");
      process.exitCode = 1;
    }
  });

// mofix apply
program
  .command("apply")
  .description("Apply a migration plan to the project")
  .argument("[projectPath]", "Path to project root (default: .)", ".")
  .option("--plan <file>", "Use a plan JSON file generated by 'mofix plan'")
  .option("--dry", "Dry-run (no file writes / installs)", false)
  .option("--verbose", "Verbose logs", false)
  .action(async (projectPath, opts) => {
    const logger = makeLogger(!!opts.verbose);
    try {
      const root = await resolveRealProjectRoot(path.resolve(projectPath));
      if (!(await fs.pathExists(root))) {
        logger.error(`Path not found: ${root}`);
        process.exitCode = 2;
        return;
      }

      let steps: any[] | undefined = undefined;

      if (opts.plan) {
        const src = await fs.readJson(path.resolve(opts.plan));
        steps = (src.plan?.steps || src.steps) as any[];
      }

      if (!steps) {
        // 플랜이 없으면 즉석 생성
        const detector = new ProjectDetector(new Logger());
        const detection = await detector.detect(root);
        const generator = new PlanGenerator(new Logger());
        const plan = await generator.generate(detection, { projectPath: root });
        steps = plan.steps as any[];
      }

      if (!Array.isArray(steps) || steps.length === 0) {
        logger.warning("No steps to apply.");
        process.exitCode = 3;
        return;
      }

      const exec = new PlanExecutor(logger as any);
      await exec.execute(
        { steps, confidence: 1, warnings: [] } as any,
        { projectPath: root, dryRun: !!opts.dry, logger } as any
      );

      logger.success(`Apply ${opts.dry ? "(dry-run) " : ""}done.`);
    } catch (err: any) {
      logger.error(err?.message || String(err));
      process.exitCode = 1;
    }
  });

program.parseAsync();
