// golden/scripts/golden-gen.ts
import fs from "fs-extra";
import path from "path";
import os from "os";
import AdmZip from "adm-zip";
import pc from "picocolors";

/**
 * Golden ZIP 자동 생성기
 * - T1/T2/T3 각각 대표 프레임워크와 까다로운 케이스를 섞어서 약 100개 ZIP 생성
 * - 생성 후 golden/zips/T{1,2,3} 아래에 .zip 파일로 저장
 *
 * 실행:
 *   npx tsx golden/scripts/golden-gen.ts
 * 또는
 *   npm run golden:gen
 */

// ------------------------------- 공통 유틸 -------------------------------

const ROOT = process.cwd();
const ZIPS_DIR = path.resolve("golden/zips");
const STAGE_DIR = path.join(os.tmpdir(), "mofix-golden-gen-stage");

async function wipeStage() {
  await fs.remove(STAGE_DIR);
  await fs.ensureDir(STAGE_DIR);
}

async function ensureTierDirs() {
  await fs.ensureDir(path.join(ZIPS_DIR, "T1"));
  await fs.ensureDir(path.join(ZIPS_DIR, "T2"));
  await fs.ensureDir(path.join(ZIPS_DIR, "T3"));
}

async function writeJsonPretty(p: string, obj: any) {
  await fs.outputFile(p, JSON.stringify(obj, null, 2) + "\n");
}

async function zipDir(srcDir: string, outZip: string) {
  const zip = new AdmZip();
  zip.addLocalFolder(srcDir);
  await fs.ensureDir(path.dirname(outZip));
  zip.writeZip(outZip);
}

function fileHeader(t: string) {
  return `/* autogenerated by golden-gen.ts (${t}) */\n`;
}

// ------------------------------- 템플릿 생성기 -------------------------------

type GenOpts = {
  name: string;      // 폴더명 (zip 베이스명)
  tier: "T1" | "T2" | "T3";
  variant?: Record<string, any>;
};

/** Next.js (App Router) */
async function genNextAppRouter(o: GenOpts) {
  const d = path.join(STAGE_DIR, o.tier, o.name);
  await fs.ensureDir(d);

  await fs.outputFile(
    path.join(d, "app", "layout.tsx"),
    fileHeader("next-app-layout") +
      `export const metadata = { title: "Next App" };
export default function RootLayout({ children }: any) {
  return <html><body style={{fontFamily:"sans-serif"}}>{children}</body></html>;
}
`
  );
  await fs.outputFile(
    path.join(d, "app", "page.tsx"),
    fileHeader("next-app-page") +
      `export default function Page() {
  return <div>Next App Router OK</div>;
}
`
  );

  const withImages = o.variant?.images === true;
  await fs.outputFile(
    path.join(d, "next.config.js"),
    fileHeader("next-config") +
      `/** @type {import('next').NextConfig} */
const nextConfig = {
  ${withImages ? "images: { formats: ['image/avif','image/webp'] }," : ""}
};
export default nextConfig;
`
  );

  await writeJsonPretty(path.join(d, "tsconfig.json"), {
    compilerOptions: { jsx: "preserve", module: "ESNext", moduleResolution: "NodeNext", strict: true },
  });

  if (o.variant?.envPort) {
    await fs.outputFile(path.join(d, ".env.local"), `PORT=${o.variant.envPort}\n`);
  }

  const deps: any = {
    next: o.variant?.nextVersion ?? "14.0.3",
    react: "18.2.0",
    "react-dom": "18.2.0",
  };
  await writeJsonPretty(path.join(d, "package.json"), {
    name: o.name,
    private: true,
    scripts: {
      dev: "next dev",
      build: "next build",
      start: "next start",
    },
    dependencies: deps,
  });

  if (o.variant?.lock === "pnpm") {
    await fs.outputFile(path.join(d, "pnpm-lock.yaml"), "# mock");
  } else if (o.variant?.lock === "yarn") {
    await fs.outputFile(path.join(d, "yarn.lock"), "# mock");
  } else if (o.variant?.lock === "npm") {
    await fs.outputFile(path.join(d, "package-lock.json"), "{}");
  }

  return d;
}

/** Next.js (Pages Router) */
async function genNextPages(o: GenOpts) {
  const d = path.join(STAGE_DIR, o.tier, o.name);
  await fs.ensureDir(d);

  await fs.outputFile(
    path.join(d, "pages", "index.js"),
    fileHeader("next-pages-index") +
      `export default function Home() { return <div>Next Pages OK</div> }`
  );

  await writeJsonPretty(path.join(d, "package.json"), {
    name: o.name,
    private: true,
    scripts: { dev: "next dev", build: "next build", start: "next start" },
    dependencies: {
      next: o.variant?.nextVersion ?? "12.3.4",
      react: "17.0.2",
      "react-dom": "17.0.2",
    },
  });

  if (o.variant?.lock === "yarn") await fs.outputFile(path.join(d, "yarn.lock"), "# mock");
  if (o.variant?.lock === "pnpm") await fs.outputFile(path.join(d, "pnpm-lock.yaml"), "# mock");
  if (o.variant?.lock === "npm") await fs.outputFile(path.join(d, "package-lock.json"), "{}");

  return d;
}

/** Vite + React */
async function genViteReact(o: GenOpts) {
  const d = path.join(STAGE_DIR, o.tier, o.name);
  await fs.ensureDir(path.join(d, "src"));

  await fs.outputFile(
    path.join(d, "src", "App.tsx"),
    fileHeader("vite-app") + `export default function App(){return <div>Vite React OK</div>}`
  );
  await fs.outputFile(
    path.join(d, "src", "main.tsx"),
    fileHeader("vite-main") +
      `import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App";
createRoot(document.getElementById("root")!).render(<App/>);`
  );
  await fs.outputFile(
    path.join(d, "index.html"),
    `<!doctype html>
<html><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/></head>
<body><div id="root"></div><script type="module" src="/src/main.tsx"></script></body></html>`
  );

  const useSwc = o.variant?.useSwc ?? false;
  await fs.outputFile(
    path.join(d, "vite.config.ts"),
    fileHeader("vite-config") +
      `import { defineConfig } from "vite";
${useSwc ? `import react from "@vitejs/plugin-react-swc";` : `import react from "@vitejs/plugin-react";`}
export default defineConfig({
  plugins: [react()],
});`
  );

  await writeJsonPretty(path.join(d, "tsconfig.json"), {
    compilerOptions: { jsx: "react-jsx", module: "ESNext", moduleResolution: "NodeNext", strict: true },
  });

  // 일부는 플러그인을 '누락'시켜 FAIL 실험 (러너 자동설치/폴백 확인용)
  const deps: any = {
    react: "18.2.0",
    "react-dom": "18.2.0",
    vite: o.variant?.viteVersion ?? "^5.2.0",
  };
  const devDeps: any = { typescript: "^5.4.0" };
  if (!o.variant?.missingPlugin) {
    if (useSwc) devDeps["@vitejs/plugin-react-swc"] = "^3.5.0";
    else devDeps["@vitejs/plugin-react"] = "^4.2.0";
  }

  await writeJsonPretty(path.join(d, "package.json"), {
    name: o.name,
    private: true,
    scripts: { dev: "vite", build: "vite build", preview: "vite preview" },
    dependencies: deps,
    devDependencies: devDeps,
  });

  if (o.variant?.lock === "yarn") await fs.outputFile(path.join(d, "yarn.lock"), "# mock");
  if (o.variant?.lock === "pnpm") await fs.outputFile(path.join(d, "pnpm-lock.yaml"), "# mock");
  if (o.variant?.lock === "npm") await fs.outputFile(path.join(d, "package-lock.json"), "{}");

  return d;
}

/** Express (TypeScript) — /api/ping + tsx 런타임 */
async function genExpressTs(o: GenOpts) {
  const d = path.join(STAGE_DIR, o.tier, o.name);
  await fs.ensureDir(path.join(d, "src"));

  await fs.outputFile(
    path.join(d, "src", "index.ts"),
    fileHeader("express-index") +
      `import express from "express";
const app = express();
const port = process.env.PORT || ${o.variant?.port ?? 4000};

// 헬스 엔드포인트
app.get("/api/ping", (_req, res) => res.json({ ok: true }));

// 기본 루트
app.get("${o.variant?.healthPath ?? "/"}", (_req,res)=>res.send("Express OK"));

app.listen(port, ()=>console.log("Server on", port));
`
  );

  await writeJsonPretty(path.join(d, "tsconfig.json"), {
    compilerOptions: {
      target: "ES2020",
      module: "ESNext",
      moduleResolution: "NodeNext",
      esModuleInterop: true,
      strict: true
    },
  });

  await writeJsonPretty(path.join(d, "package.json"), {
    name: o.name,
    private: true,
    type: "module",
    scripts: {
      dev: "tsx watch src/index.ts"  // ← 안정적인 tsx 러너
    },
    dependencies: { express: "^4.18.2" },
    devDependencies: {
      tsx: "^4.20.0",                // ← 추가
      typescript: "^5.4.0"
    },
  });

  if (o.variant?.lock === "npm") await fs.outputFile(path.join(d, "package-lock.json"), "{}");
  if (o.variant?.lock === "yarn") await fs.outputFile(path.join(d, "yarn.lock"), "# mock");
  if (o.variant?.lock === "pnpm") await fs.outputFile(path.join(d, "pnpm-lock.yaml"), "# mock");

  return d;
}

/** CRA (Legacy) — dev 스크립트 추가 */
async function genCRA(o: GenOpts) {
  const d = path.join(STAGE_DIR, o.tier, o.name);
  await fs.ensureDir(path.join(d, "src"));

  await fs.outputFile(path.join(d, "src", "App.js"), fileHeader("cra-app") + `export default ()=> <div>CRA OK</div>`);
  await fs.outputFile(
    path.join(d, "src", "index.js"),
    fileHeader("cra-index") +
      `import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App";
createRoot(document.getElementById("root")).render(<App/>);`
  );
  await fs.outputFile(
    path.join(d, "public", "index.html"),
    `<!doctype html><html><body><div id="root"></div></body></html>`
  );

  await writeJsonPretty(path.join(d, "package.json"), {
    name: o.name,
    private: true,
    scripts: {
      start: "react-scripts start",
      dev: "react-scripts start",
      build: "react-scripts build"
    },
    dependencies: {
      react: "^18.2.0",
      "react-dom": "^18.2.0",
      "react-scripts": "5.0.1"
    }
  });

  if (o.variant?.lock === "npm") await fs.outputFile(path.join(d, "package-lock.json"), "{}");
  if (o.variant?.lock === "yarn") await fs.outputFile(path.join(d, "yarn.lock"), "# mock");

  return d;
}

/** Monorepo — pnpm workspace + 정확한 packageManager semver */
async function genMonorepoSimple(o: GenOpts) {
  const d = path.join(STAGE_DIR, o.tier, o.name);
  const web = path.join(d, "apps", "web");
  await fs.ensureDir(web);

  // 하위 웹 앱은 Next App Router
  await genNextAppRouter({ name: "web", tier: o.tier, variant: { nextVersion: "14.0.3" } });
  const src = path.join(STAGE_DIR, o.tier, "web");
  await fs.move(src, web, { overwrite: true });

  await writeJsonPretty(path.join(d, "package.json"), {
    name: o.name,
    private: true,
    packageManager: "pnpm@8.15.4",   // ← semver 명시
    workspaces: ["apps/*"],
    scripts: {
      dev: "pnpm --filter web run dev",
      build: "pnpm --filter web run build"
    }
  });

  // pnpm workspace 선언 파일
  await fs.outputFile(path.join(d, "pnpm-workspace.yaml"), "packages:\n  - 'apps/*'\n");

  // 루트에 락파일 목업
  await fs.outputFile(path.join(d, "pnpm-lock.yaml"), "# mock");

  return d;
}

/** 대용량 정적 자산 + Next app */
async function genLargeStatic(o: GenOpts) {
  const d = path.join(STAGE_DIR, o.tier, o.name);
  await fs.ensureDir(path.join(d, "public"));
  for (let i = 0; i < (o.variant?.files ?? 5); i++) {
    const buf = Buffer.alloc(5 * 1024 * 1024, i); // 5MB
    await fs.outputFile(path.join(d, "public", `asset-${i}.bin`), buf);
  }
  await genNextAppRouter({ name: o.name + "-_inner", tier: o.tier });
  const inner = path.join(STAGE_DIR, o.tier, o.name + "-_inner");
  await fs.copy(inner, d, { overwrite: true });
  await fs.remove(inner);
  return d;
}

/** Mixed ESM+CJS (Express) */
async function genEsmiCjsMix(o: GenOpts) {
  const d = path.join(STAGE_DIR, o.tier, o.name);
  await fs.ensureDir(path.join(d, "srv"));

  await fs.outputFile(
    path.join(d, "srv", "cjs-helper.cjs"),
    `module.exports = { msg: "CJS OK" };\n`
  );
  await fs.outputFile(
    path.join(d, "srv", "index.ts"),
    fileHeader("esm-cjs") +
      `import express from "express";
const { msg } = require("./cjs-helper.cjs");
const app = express();
const port = process.env.PORT || 4001;
app.get("/", (_req,res)=>res.send("Mix " + msg));
app.listen(port, ()=>console.log("Mix on", port));
`
  );

  await writeJsonPretty(path.join(d, "package.json"), {
    name: o.name,
    private: true,
    type: "module",
    scripts: { dev: "ts-node-dev srv/index.ts" },
    dependencies: { express: "^4.18.2" },
    devDependencies: { "ts-node-dev": "^2.0.0", typescript: "^5.4.0" },
  });

  return d;
}

// ------------------------------- 생성 플랜 -------------------------------

type PlanItem = {
  tier: "T1" | "T2" | "T3";
  template: "next-app" | "next-pages" | "vite-react" | "express-ts" | "cra" | "monorepo" | "large-static" | "esm-cjs";
  count: number;
  variant?: (i: number) => Record<string, any>;
  basename: string; // zip 파일명 prefix
};

const PLAN: PlanItem[] = [
  // T1 (20~30)
  { tier: "T1", template: "next-app", basename: "T1_next-basic", count: 5, variant: i => ({ lock: ["npm","yarn","pnpm"][i%3] }) },
  { tier: "T1", template: "next-pages", basename: "T1_next-pages", count: 3, variant: i => ({}) },
  { tier: "T1", template: "vite-react", basename: "T1_vite-react-basic", count: 5, variant: i => ({ missingPlugin: i%4===0, lock: ["npm","yarn","pnpm"][i%3] }) },
  { tier: "T1", template: "express-ts", basename: "T1_express-basic", count: 4, variant: i => ({ port: 4000 + i, lock: ["npm","yarn","pnpm"][i%3] }) },
  { tier: "T1", template: "cra", basename: "T1_cra-basic", count: 3, variant: i => ({ lock: ["npm","yarn"][i%2] }) },
  { tier: "T1", template: "monorepo", basename: "T1_monorepo-simple", count: 2, variant: i => ({}) },

  // T2 (40~50)
  { tier: "T2", template: "next-app", basename: "T2_next-mixed", count: 6, variant: i => ({ images: i%2===0, envPort: 3000+i }) },
  { tier: "T2", template: "vite-react", basename: "T2_vite-img-opt", count: 6, variant: i => ({ useSwc: i%2===0 }) },
  { tier: "T2", template: "express-ts", basename: "T2_proxy-ws", count: 5, variant: i => ({ healthPath: "/", port: 4100 + i }) },
  { tier: "T2", template: "next-pages", basename: "T2_next-legacy", count: 5, variant: i => ({ nextVersion: "12.3.4" }) },
  { tier: "T2", template: "esm-cjs", basename: "T2_module-esm-cjs", count: 4, variant: i => ({}) },
  { tier: "T2", template: "large-static", basename: "T2_large", count: 4, variant: i => ({ files: 3 + (i%3) }) },
  { tier: "T2", template: "monorepo", basename: "T2_turbo-like", count: 3, variant: i => ({}) },
  { tier: "T2", template: "cra", basename: "T2_cra-alt", count: 3, variant: i => ({}) },

  // T3 (20~30)
  { tier: "T3", template: "large-static", basename: "T3_static-huge", count: 6, variant: i => ({ files: 6 }) },
  { tier: "T3", template: "vite-react", basename: "T3_vite-hard", count: 6, variant: i => ({ missingPlugin: i%3===0, useSwc: i%2===1 }) },
  { tier: "T3", template: "next-app", basename: "T3_next-hard", count: 6, variant: i => ({ images: true }) },
];

async function generateOne(p: PlanItem, idx: number) {
  const name = `${p.basename}-${String(idx + 1).padStart(2, "0")}`;
  const variant = p.variant ? p.variant(idx) : {};
  let madeDir = "";

  switch (p.template) {
    case "next-app":
      madeDir = await genNextAppRouter({ name, tier: p.tier, variant });
      break;
    case "next-pages":
      madeDir = await genNextPages({ name, tier: p.tier, variant });
      break;
    case "vite-react":
      madeDir = await genViteReact({ name, tier: p.tier, variant });
      break;
    case "express-ts":
      madeDir = await genExpressTs({ name, tier: p.tier, variant });
      break;
    case "cra":
      madeDir = await genCRA({ name, tier: p.tier, variant });
      break;
    case "monorepo":
      madeDir = await genMonorepoSimple({ name, tier: p.tier, variant });
      break;
    case "large-static":
      madeDir = await genLargeStatic({ name, tier: p.tier, variant });
      break;
    case "esm-cjs":
      madeDir = await genEsmiCjsMix({ name, tier: p.tier, variant });
      break;
    default:
      throw new Error(`Unknown template ${p.template}`);
  }

  const outZip = path.join(ZIPS_DIR, p.tier, `${name}.zip`);
  await zipDir(madeDir, outZip);
  return { outZip, madeDir };
}

async function main() {
  console.log(pc.cyan(">> Golden ZIP generator start"));
  await ensureTierDirs();
  await wipeStage();

  let total = 0;
  for (const item of PLAN) {
    for (let i = 0; i < item.count; i++) {
      const { outZip } = await generateOne(item, i);
      total++;
      console.log(pc.dim(`  + ${path.relative(ROOT, outZip)}`));
    }
  }

  console.log(pc.green(`\n✅ Generated ${total} ZIPs under ${path.relative(ROOT, ZIPS_DIR)}`));
  console.log(pc.bold("\nRun tests:"));
  console.log(pc.bold("  ZIP_DIR=golden/zips/T1 npm run golden:run"));
  console.log(pc.bold("  ZIP_DIR=golden/zips/T2 npm run golden:run"));
  console.log(pc.bold("  ZIP_DIR=golden/zips/T3 npm run golden:run"));
}

main().catch((e) => {
  console.error(pc.red(String(e)));
  process.exit(1);
});
